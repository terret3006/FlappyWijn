<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>FlappyWijn</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <link rel="icon" type="image/png" href="assets/face_2.png" />
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #111;
            color: #fff;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            overflow: hidden;
        }

        .wrap {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 10px;
        }

        #game {
            display: block;
            background: #000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
            border-radius: 10px;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            max-width: 100vw;
            max-height: 70vh;
            width: auto;
            height: auto;
        }

        .row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .hint img {
            vertical-align: middle;
            margin: 0 2px;
        }


        button {
            background: linear-gradient(145deg, #1a1a1a, #222);
            color: #d6e110;
            border: 2px solid #de9425;
            border-radius: 12px;
            padding: 10px 18px;
            cursor: pointer;
            font-weight: 700;
            font-size: 15px;
            letter-spacing: 1px;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(210, 118, 12, 0.5), inset 0 0 5px rgba(0, 255, 204, 0.2);
            transition: all 0.2s ease;
        }

        button:hover {
            background: #e07b06;
            color: #111;
            box-shadow: 0 0 15px rgba(193, 88, 13, 0.9), inset 0 0 10px rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.98);
            box-shadow: 0 0 6px rgba(0, 255, 204, 0.8);
        }
    </style>
</head>

<body>
    <div class="wrap">
        <canvas id="game" width="1200" height="720"></canvas>
        <div class="row">
            <button id="btnStart">Start (Space)</button>
            <button id="btnJump">Jump (Space)</button>
            <button id="btnReset">Reset (R)</button>
        </div>
        <div class="hint">
            Pass pipes (+1). Collect
            <img src="assets/croissant.png" width="24" height="24" alt="Croissant"> (+2),
            <img src="assets/fries.png" width="24" height="24" alt="Fries"> (+3),
            <img src="assets/poop.png" width="24" height="24" alt="Poop"> (+2).
            Avoid
            <img src="assets/contract.png" width="24" height="24" alt="Contract"> (–4),
            <img src="assets/samosa.png" width="24" height="24" alt="Samosa"> (–2).
            Space = flap, R = restart.
        </div>

    </div>

    <script>
        // ============================
        // CONFIG
        // ============================
        const WIDTH = 1200, HEIGHT = 720;
        const FPS = 60;
        const SPAWN_FRAMES = 90;

        const GRAVITY = 0.075;
        const JUMP = -2.75;
        const PIPE_GAP_START = 300;
        const PIPE_GAP_MIN = 350;
        const PIPE_SPEED_START = 2.0;
        const PIPE_SPEED_MAX = 5.0;

        const POINT_PIPE = 1;
        const POINT_CROISSANT = 2;
        const POINT_FRIES = 3;
        const POINT_JOB = -4;
        const POINT_SAMOSA = -2;
        const POINT_POOP = 2;

        const DAY_NIGHT_PERIOD_SEC = 40;

        // Pipes visuals
        const PIPE_BODY = "#56B04B";
        const PIPE_SIDE = "#3E8C37";
        const PIPE_CAP = "#3C7830";
        const GROUND_COLOR = "#DED895";
        const PIPE_W = 60;
        const CAP_H = 16;
        const SIDE_W = 10;
        const GROUND_HEIGHT = 0;

        let streak = 0;               // counts consecutive positives
        let multiplier = 1;           // current score multiplier
        let multiplierTimer = 0;      // for flashing on screen
        let multiplierText = "";      // "2x" or "3x"


        // ============================
        // CANVAS
        // ============================
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");



        // ============================
        // MUSIC / JUKEBOX SETUP
        // ============================
        let musicOn = false;
        const songs = [
            "assets/bg_music_1.mp3",
            "assets/bg_music_2.mp3",
            "assets/bg_music_3.mp3",
            "assets/bg_music_4.mp3"
        ];
        let currentSong = 0;

        const music = new Audio(songs[currentSong]);
        music.loop = true;
        music.volume = 0;
        const targetVolume = 0.1;
        let fadeInterval = null;

        // Music icon & jukebox buttons dimensions
        const iconX = 20, iconY = HEIGHT - 50, iconSize = 32;
        const prevX = 60, nextX = 100, btnY = HEIGHT - 50, btnSize = 32;

        // ============================
        // FADE FUNCTION
        // ============================
        function fadeMusic(toVolume, duration = 500, callback) {
            if (fadeInterval) clearInterval(fadeInterval);

            const startVolume = music.volume;
            const diff = toVolume - startVolume;
            const steps = 20;
            const stepTime = duration / steps;
            let stepCount = 0;

            fadeInterval = setInterval(() => {
                stepCount++;
                music.volume = startVolume + (diff * stepCount / steps);
                if (stepCount >= steps) {
                    music.volume = toVolume;
                    clearInterval(fadeInterval);
                    fadeInterval = null;
                    if (toVolume === 0) music.pause();
                    if (callback) callback();
                }
            }, stepTime);
        }

        // ============================
        // CHANGE SONG FUNCTION
        // ============================
        function playSong(index) {
            index = (index + songs.length) % songs.length; // wrap around
            currentSong = index;

            if (musicOn) {
                fadeMusic(0, 300, () => { // fade out current
                    music.src = songs[currentSong];
                    music.play();
                    fadeMusic(targetVolume, 500); // fade in new song
                });
            } else {
                music.src = songs[currentSong]; // just change source if music off
            }
        }

        // ============================
        // CANVAS CLICK HANDLER
        // ============================
        canvas.addEventListener("click", (e) => {
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
            const my = (e.clientY - rect.top) * (canvas.height / rect.height);

            // Toggle music
            if (mx >= iconX && mx <= iconX + iconSize && my >= iconY && my <= iconY + iconSize) {
                musicOn = !musicOn;
                if (musicOn) {
                    music.play();
                    fadeMusic(targetVolume, 500);
                } else {
                    fadeMusic(0, 500);
                }
            }


            // Previous track
            if (mx >= prevX && mx <= prevX + btnSize && my >= btnY && my <= btnY + btnSize) {
                playSong(currentSong - 1);
            }

            // Next track
            if (mx >= nextX && mx <= nextX + btnSize && my >= btnY && my <= btnY + btnSize) {
                playSong(currentSong + 1);
            }
        });

        // ============================
        // HUD DRAW FUNCTION
        // ============================
        function drawMusicHUD(ctx) {
            // Music toggle icon
            ctx.fillStyle = "#fff";
            ctx.font = "28px Arial";
            ctx.textBaseline = "top";
            const icon = musicOn ? "🎵" : "🔇";
            ctx.fillText(icon, iconX, iconY);

            // Previous / Next buttons
            ctx.fillText("⏮️", prevX, btnY);
            ctx.fillText("⏭️", nextX, btnY);

            // Optional: display current song number or name
            ctx.font = "18px Arial";
            ctx.fillText(`Track ${currentSong + 1}`, 150, btnY + 4);
        }





        // ============================
        // STATE
        // ============================
        let faceImg, croissantImg, friesImg, jobImg, samosaImg, poopImg, pipeImg;

        let faceX = 100, faceY = HEIGHT / 2, faceVel = 0;
        const FACE_W = 60, FACE_H = 60;

        let pipes = [];
        let items = [];
        let clouds = [];
        let stars = [];

        let score = 0;
        let croissantCount = 0;
        let friesCount = 0;
        let jobCount = 0;
        let samosaCount = 0;
        let poopCount = 0;
        let pipeCount = 0;

        let pipeGap = PIPE_GAP_START;
        let pipeSpeed = PIPE_SPEED_START;
        let spawnTimer = 0;

        let running = true;
        let gameOver = false;
        let started = false;

        // score flash
        let lastScoreChange = 0;
        let lastChangeTime = 0;

        // timing
        let lastFrameTime = 0;

        // ============================
        // ASSETS
        // ============================
        function loadImage(path) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = (e) => reject(e);
                img.src = path;
            });
        }

        async function loadAssets() {
            [
                faceImg,
                croissantImg,
                friesImg,
                jobImg,
                samosaImg,
                poopImg,
                pipeImg
            ] = await Promise.all([
                loadImage("assets/face_2.png"),
                loadImage("assets/croissant.png"),
                loadImage("assets/fries.png"),
                loadImage("assets/contract.png"),
                loadImage("assets/samosa.png"),
                loadImage("assets/poop.png"),
                loadImage("assets/pipe.png"),
            ]);
        }

        // ============================
        // HELPERS
        // ============================
        function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
        function nowSec() { return performance.now() / 1000; }

        function reset() {
            pipes.length = 0;
            items.length = 0;

            faceX = 100;
            faceY = HEIGHT / 2;
            faceVel = 0;

            score = 0;
            croissantCount = 0;
            friesCount = 0;
            jobCount = 0;
            samosaCount = 0;
            poopCount = 0;
            pipeCount = 0;

            pipeGap = PIPE_GAP_START;
            pipeSpeed = PIPE_SPEED_START;
            spawnTimer = 0;

            gameOver = false;
            started = false;

            // Clouds
            clouds = Array.from({ length: 5 }, () => ({
                x: randInt(0, WIDTH),
                y: randInt(30, 120),
            }));

            // Stars
            stars = [];
            for (let i = 0; i < 50; i++) {
                stars.push({
                    x: randInt(0, WIDTH),
                    y: randInt(0, Math.floor(HEIGHT / 2)),
                    size: randInt(1, 3),
                    color: [
                        [255, 255, 200],
                        [200, 220, 255],
                        [255, 220, 200]
                    ][randInt(0, 2)]
                });
            }
        }

        function currentSpacingPixels(speed) {
            return Math.floor(speed * SPAWN_FRAMES);
        }

        function spawnPipeAndItems() {
            const gapY = randInt(80 + (pipeGap >> 1), HEIGHT - 80 - (pipeGap >> 1));
            const pipeX = WIDTH;
            pipes.push({ x: pipeX, gapY, scored: false });

            const safeTop = 40;
            const safeBottom = HEIGHT - 40;
            const spacingPx = Math.max(140, currentSpacingPixels(pipeSpeed));
            const base = pipeX + 40;
            const limit = pipeX + Math.max(80, spacingPx - 60);

            function placeItem(kind) {
                const x = randInt(base, limit);
                const y = randInt(safeTop, safeBottom);
                items.push({ x, y, type: kind });
            }

            // always a croissant
            placeItem("croissant");
            // maybe fries
            if (Math.random() < 0.5) placeItem("fries");

            // job probability grows with croissant+fries
            const jobProb = Math.min(0.15 + 0.02 * (croissantCount + friesCount), 0.6);
            if (Math.random() < jobProb) placeItem("job");

            // samosa 30%
            if (Math.random() < 0.3) placeItem("samosa");

            // poop 20%
            if (Math.random() < 0.2) placeItem("poop");
        }

        // ============================
        // DRAWING
        // ============================
        function drawGradientBackground() {
            const t = nowSec();
            const phase = (Math.sin((2 * Math.PI * t) / DAY_NIGHT_PERIOD_SEC) + 1) / 2;

            const topColor = [
                Math.round(0 * (1 - phase) + 0 * phase),
                Math.round(50 * (1 - phase) + 0 * phase),
                Math.round(150 * (1 - phase) + 20 * phase),
            ];
            const bottomColor = [
                Math.round(150 * (1 - phase) + 0 * phase),
                Math.round(200 * (1 - phase) + 0 * phase),
                Math.round(255 * (1 - phase) + 20 * phase),
            ];

            const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
            grad.addColorStop(0, `rgb(${topColor.join(",")})`);
            grad.addColorStop(1, `rgb(${bottomColor.join(",")})`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Daytime clouds
            if (phase < 0.5) {
                for (const c of clouds) {
                    // shadow
                    ctx.fillStyle = "rgb(180,180,180)";
                    ctx.beginPath();
                    ctx.ellipse(c.x + 5, c.y + 5, 40, 20, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // main fluffy body
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.ellipse(c.x, c.y, 40, 20, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(c.x - 20, c.y + 5, 25, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(c.x + 40, c.y + 5, 25, 15, 0, 0, Math.PI * 2);
                    ctx.fill();

                    c.x -= 0.2;
                    if (c.x < -100) {
                        c.x = WIDTH + randInt(0, 50);
                        c.y = randInt(30, 120);
                    }
                }
            }

            // Nighttime stars
            if (phase > 0.5) {
                for (const s of stars) {
                    const brightness = Math.max(180, Math.min(255, Math.floor(200 + 55 * Math.sin(performance.now() / 1000 * 3 + s.x))));
                    const r = Math.min(255, Math.floor(s.color[0] * brightness / 255));
                    const g = Math.min(255, Math.floor(s.color[1] * brightness / 255));
                    const b = Math.min(255, Math.floor(s.color[2] * brightness / 255));
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                    ctx.fill();

                    if (s.size > 2) {
                        ctx.fillRect(s.x - 2, s.y, 4, 1);
                        ctx.fillRect(s.x, s.y - 2, 1, 4);
                    }
                }
            }
        }

        function drawPipes() {
            for (const p of pipes) {
                const x = Math.floor(p.x);
                const gapY = p.gapY;
                const topH = gapY - (pipeGap >> 1);
                const botY = gapY + (pipeGap >> 1);

                // bodies
                ctx.fillStyle = PIPE_BODY;
                ctx.fillRect(x, 0, PIPE_W, topH);
                ctx.fillRect(x, botY, PIPE_W, HEIGHT - botY);

                // side shading
                ctx.fillStyle = PIPE_SIDE;
                ctx.fillRect(x + PIPE_W - SIDE_W, 0, SIDE_W, topH);
                ctx.fillRect(x + PIPE_W - SIDE_W, botY, SIDE_W, HEIGHT - botY);

                // caps
                ctx.fillStyle = PIPE_CAP;
                ctx.fillRect(x - 4, topH - CAP_H, PIPE_W + 8, CAP_H);
                ctx.fillRect(x - 4, botY, PIPE_W + 8, CAP_H);
            }
        }

        function drawItems() {
            for (const it of items) {
                const x = Math.floor(it.x), y = Math.floor(it.y);
                let img = croissantImg;
                if (it.type === "fries") img = friesImg;
                else if (it.type === "job") img = jobImg;
                else if (it.type === "samosa") img = samosaImg;
                else if (it.type === "poop") img = poopImg;
                ctx.drawImage(img, x, y, 32, 32);
            }
        }

        function drawHUD() {
            const spacing = 100;
            const startX = 20;
            const y = 10;

            const list = [
                { img: croissantImg, count: croissantCount, positive: true },
                { img: friesImg, count: friesCount, positive: true },
                { img: samosaImg, count: samosaCount, positive: false },
                { img: poopImg, count: poopCount, positive: true },
                { img: jobImg, count: jobCount, positive: false },
            ];

            ctx.textBaseline = "top";
            ctx.font = "bold 20px system-ui, Arial";
            for (let i = 0; i < list.length; i++) {
                const x = startX + i * spacing;
                ctx.drawImage(list[i].img, x, y, 32, 32);
                ctx.fillStyle = list[i].positive ? "#00ff00" : "#ff0000";
                ctx.fillText(String(list[i].count), x + 40, y + 5);
            }

            // Score with flash
            const t = performance.now() / 1000;
            let color = "#ffff00";
            if (t - lastChangeTime < 0.5) {
                color = lastScoreChange > 0 ? "#00ff00" : (lastScoreChange < 0 ? "#ff0000" : "#ffff00");
            }
            ctx.font = "bold 28px system-ui, Arial";
            const text = String(score);
            const tw = ctx.measureText(text).width;
            ctx.fillStyle = color;
            ctx.fillText(text, WIDTH / 2 - tw / 2, 50);
            // Draw multiplier flash
            // Draw multiplier animation
            if (multiplier > 1) {
                const t = performance.now() / 1000;
                const elapsed = t - multiplierTimer;

                if (elapsed < 1) { // show for 1 second
                    // Zoom effect: start bigger and shrink to normal
                    const scale = 1 + 0.5 * Math.sin(Math.PI * (1 - elapsed)); // from 1.5 -> 1

                    // Wobble effect: horizontal shift
                    const wobble = Math.sin(elapsed * 10) * 10; // ±10px

                    // Fade out
                    const alpha = 1 - elapsed;

                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.font = "bold 36px system-ui, Arial";
                    ctx.fillStyle = "#ff0";

                    // Move to center, apply scale
                    const tw = ctx.measureText(multiplierText).width;
                    ctx.translate(WIDTH / 2 + wobble, 100);
                    ctx.scale(scale, scale);
                    ctx.fillText(multiplierText, -tw / 2, 0);
                    ctx.restore();
                }
            }
            // draw jukebox/music controls
            drawMusicHUD(ctx);

        }

        function drawGameOver() {
            // Background overlay
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Main title
            ctx.fillStyle = "#fffa";
            ctx.font = "bold 48px system-ui, Arial";
            ctx.textAlign = "center";
            ctx.fillText("Game Over", WIDTH / 2, HEIGHT / 4);

            // Final score
            ctx.fillStyle = "#fff";
            ctx.font = "bold 36px system-ui, Arial";
            ctx.fillText(`Final Score: ${score}`, WIDTH / 2, HEIGHT / 4 + 50);

            // Counters block
            let offsetY = HEIGHT / 4 + 100;
            const step = 50;

            function row(img, value, label) {
                // Background rounded rectangle
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.beginPath();
                ctx.roundRect(WIDTH / 2 - 110, offsetY, 200, 40, 10);
                ctx.fill();

                // Icon shadow
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.shadowBlur = 4;
                ctx.drawImage(img, WIDTH / 2 - 90, offsetY, 32, 32);
                ctx.shadowBlur = 0;

                // Value
                ctx.fillStyle = "#fff";
                ctx.font = "24px system-ui, Arial";
                ctx.fillText(`${label}: ${value}`, WIDTH / 2, offsetY + 8);

                offsetY += step;
            }

            row(croissantImg, croissantCount, "Croissant");
            row(friesImg, friesCount, "Fries");
            row(jobImg, jobCount, "Job");
            row(samosaImg, samosaCount, "Samosa");
            row(poopImg, poopCount, "Poop");

            // ---- Pipe row (custom drawing) ---- 
            const px = WIDTH / 2 - 70, py = offsetY + 20, pw = 16, ph = 24;
            // Body 
            ctx.fillStyle = "#0a0"; // green 
            ctx.fillRect(px, py, pw, ph);
            // Side shading 
            ctx.fillStyle = "#060";
            ctx.fillRect(px + pw - 6, py, 6, ph);
            // Cap 
            ctx.fillStyle = "#080";
            ctx.fillRect(px - 2, py - 6, pw + 4, 6);
            // Cap highlight 
            ctx.fillStyle = "#0c0";
            ctx.fillRect(px + 4, py - 4, pw - 8, 2);

            // Pipe score
            ctx.fillStyle = "#fff";
            ctx.fillText(`Pipes: ${pipeCount}`, WIDTH / 2, offsetY + 20);
            offsetY += step;

            // Restart button
            ctx.fillStyle = "rgba(255,255,255,0.2)";
            ctx.fillRect(WIDTH / 2 - 120, offsetY + 25, 240, 50);
            ctx.fillStyle = "#fff";
            ctx.font = "bold 28px system-ui, Arial";
            ctx.fillText("Press R to Restart", WIDTH / 2, offsetY + 34);
        }



        // ============================
        // INPUT
        // ============================
        function flap() {
            if (!gameOver) {
                started = true;
                faceVel = JUMP;
            }
        }
 window.addEventListener("keydown", (e) => {
    if (e.code === "Space") { e.preventDefault(); flap(); }
    if (e.code === "KeyR" && gameOver) reset();
});

document.getElementById("btnStart").onclick = flap;
document.getElementById("btnJump").onclick = flap;
document.getElementById("btnReset").onclick = () => { if (gameOver) reset(); };

canvas.addEventListener("click", (e) => {
    handleInput(e.clientX, e.clientY);
});

        // ============================
        // GAME LOOP
        // ============================
        function update(dt) {
            if (gameOver || !started) return;

            faceVel += GRAVITY;
            faceY += faceVel;

            spawnTimer += 1;
            if (spawnTimer >= SPAWN_FRAMES) {
                spawnPipeAndItems();
                spawnTimer = 0;
            }

            // Move pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                const p = pipes[i];
                p.x -= pipeSpeed;

                // Score when player passes the pipe
                if (!p.scored && (faceX > p.x + PIPE_W)) {
                    score += POINT_PIPE;
                    pipeCount += 1;
                    lastScoreChange = POINT_PIPE;
                    lastChangeTime = performance.now() / 1000;
                    p.scored = true;
                }
                // Remove off-screen
                if (p.x + PIPE_W < 0) pipes.splice(i, 1);
            }

            // Move items and collisions
            const faceRect = { x: faceX, y: faceY, w: FACE_W, h: FACE_H };
            for (let i = items.length - 1; i >= 0; i--) {
                const it = items[i];
                it.x -= pipeSpeed;
                const itRect = { x: it.x, y: it.y, w: 32, h: 32 };

                if (itRect.x + itRect.w < 0) {
                    items.splice(i, 1);
                    continue;
                }

                if (rectsOverlap(faceRect, itRect)) {
                    let positiveHit = false;

                    if (it.type === "croissant") {
                        croissantCount++; score += POINT_CROISSANT; lastScoreChange = POINT_CROISSANT; positiveHit = true;
                    } else if (it.type === "fries") {
                        friesCount++; score += POINT_FRIES; lastScoreChange = POINT_FRIES; positiveHit = true;
                    } else if (it.type === "poop") {
                        poopCount++; score += POINT_POOP; lastScoreChange = POINT_POOP; positiveHit = true;
                    } else if (it.type === "job") {
                        jobCount++; score += POINT_JOB; lastScoreChange = POINT_JOB;
                    } else if (it.type === "samosa") {
                        samosaCount++; score += POINT_SAMOSA; lastScoreChange = POINT_SAMOSA;
                    }

                    // ---- Multiplier logic ----
                    if (positiveHit) {
                        streak++;
                    } else {
                        streak = 0;
                        multiplier = 1;
                    }

                    if (streak >= 12) {
                        multiplier = 3;
                        multiplierText = "3x";
                        multiplierTimer = performance.now() / 1000;
                    } else if (streak >= 6) {
                        multiplier = 2;
                        multiplierText = "2x";
                        multiplierTimer = performance.now() / 1000;
                    } else {
                        multiplier = 1;
                    }

                    // Apply multiplier to score
                    if (positiveHit && multiplier > 1) {
                        const bonus = lastScoreChange * (multiplier - 1);
                        score += bonus;
                        lastScoreChange += bonus;  // for HUD flash
                    }

                    lastChangeTime = performance.now() / 1000;
                    items.splice(i, 1);
                }

            }

            // Collisions with pipes
            for (const p of pipes) {
                const x = p.x, gapY = p.gapY;
                const top = gapY - (pipeGap >> 1);
                const bot = gapY + (pipeGap >> 1);
                const withinX = (faceX + FACE_W > x) && (faceX < x + PIPE_W);
                if (withinX) {
                    if (faceY < top || (faceY + FACE_H) > bot) {
                        gameOver = true;
                        break;
                    }
                }
            }

            // Out of bounds
            if (faceY > HEIGHT || faceY < -40) {
                gameOver = true;
            }

            // Difficulty scaling
            const difficultyProgress = croissantCount + friesCount;
            pipeGap = Math.max(PIPE_GAP_MIN, PIPE_GAP_START - difficultyProgress * 3.5);
            pipeSpeed = Math.min(PIPE_SPEED_MAX, PIPE_SPEED_START + difficultyProgress * 0.055);
        }

        function rectsOverlap(a, b) {
            return a.x < b.x + b.w &&
                a.x + a.w > b.x &&
                a.y < b.y + b.h &&
                a.y + a.h > b.y;
        }

        function draw() {
            drawGradientBackground();
            drawPipes();
            drawItems();
            ctx.drawImage(faceImg, Math.floor(faceX), Math.floor(faceY), FACE_W, FACE_H);
            // ground (visual only; set height >0 to show a strip)
            // ctx.fillStyle = GROUND_COLOR;
            // ctx.fillRect(0, HEIGHT - 50, WIDTH, 50);

            drawHUD();
            if (gameOver) drawGameOver();
        }

        function loop(ts) {
            const dt = (ts - lastFrameTime) / 1000;
            lastFrameTime = ts;
            if (running) update(dt);
            draw();
            requestAnimationFrame(loop);
        }

        // ============================
        // BOOT
        // ============================
        (async function main() {
            await loadAssets();
            reset();
            requestAnimationFrame(loop);
        })();
    </script>
</body>

</html>